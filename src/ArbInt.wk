#>
# Source Code for the Arbitrary Integer Library for the
# Programming Language Wake
#
# ArbInt.wk
#
# Licensed under the MIT license
# See LICENSE.TXT for details
#
# Author: Nathan Fairhurst
# Revised By:
#
##

every ArbInt is:
	
	//ArbInt is an Integer of Arbitrary Size.  It is stored as a Little Endian array of Nums
	//with 32(?) bit words (and the nums themselves are big endian).

	needs Num[];
	
	provides ArbInt <- ArbInt(?Num[]);
	
	with Num leftBit = 1 << 31;										//FORCES 32 BIT
	with Num rightBit = 1;
	
	Num[] -- add(Num[] other) {
		//Addition with only bitwise operators is fairly simple
		//First, a ^ b naively sums a, b, but ignores when the 1 is carried.
		//Then, (a & b) << 1 is the carried result, previously ignored.
		//Then this processes is repeated, adding our naive sum and our carry result
		//We iterate until there's nothing to carry, and we're done!
		//It does get a bit more complicated when we need to manage multiple words...
		
		//define our variables
		var Num[] a = Num[];
		var Num[] b = other;
		
		var sum Num[] = [];
		var carry Num[] = [];
		var prevSum Num[] = [];
		
		var Num i = 0;
		var Num j = 0;
		
		//First, determine the largest ArbInt, we'll need to make all our ArbInts this size + 1
		var Num mostWords = a.getSize().orMaxOf(b.getSize());
		
		//Create prevSum and get our first sum & carry result (don't bitshift carry)
		for (i = 0; i < mostWords; i += 1) {
			if (i >= a.getSize()) {
				if ((leftBit & a[a.getSize()-1]) == leftBit) {
					sum.push(~b[i]);
					carry.push(b[i]);
				} else {
					sum.push(b[i]);
					carry.push(0);
				}
			} else if (i >= b.getSize()) {
				if ((leftBit & b[b.getSize()-1]) == leftBit) {
					sum.push(~a[i]);
					carry.push(a[i]);
				} else {
					sum.push(a[i]);
					carry.push(0);
				}
			} else {
				sum.push(a[i] ^ b[i]);
				carry.push(a[i] & b[i]);
			}
			prevSum.push(0);
		}
		
		//add one extra word in case of overflow (ex 1000 + 1000 = 0000 0001)
		//the extra word needs to be filled with the sign of the number
		//so its value will not be altered.
		if ((leftBit & sum[mostWords - 1]) == leftBit) {
			sum.push(-1);
		} else {
			sum.push(0);
		}
		if ((leftBit & carry[mostWords - 1]) == leftBit) {
			carry.push(-1);
		} else {
			carry.push(0);
		}
		prevSum.push(0);
		
		//for each carry word, starting at the smallest
		for (i = 0; i <= mostWords; i+=1) {
			//continue adding and carrying until the next smallest carry word is zero
			while (carry[i] != 0) {
				//bitshifting the carry must move the left bit of the smaller word into
				//the larger carry word's right bit after it itself has been bitshifted
				//iterate in reverse so nothing is lost.
				for (j = mostWords; j >= i; j-=1) {
					carry[j] = carry[j] << 1;
					if (((j != i) && (leftBit & carry[j-1]) == leftBit)) {
						carry[j] = carry[j] | rightBit;
					}
				}
				
				//sum and carry each word that isn't finished
				//but don't bitshift the carry yet
				for (j = i; j <= mostWords; j+=1) {
					prevSum[j] = sum[j];
					sum[j] = prevSum[j] ^ carry[j];
					carry[j] = prevSum[j] & carry[j];
				}
			}
		}
		
		return sum;
	}
	
	ArbInt -- add(ArbInt other) {
		return finalizeArbIntFromNumList(add(other.toNumList()));
	}
	
	private Num[] -- mult(other Num[]) {
		var Num i = 0;
		var Num j = 0;
		
		var Num[] result = [0];
		var Num thisBit = 0;
		
		for (i=0; i<other.getSize(); i+=1) {
			for (j=0; j<32; i+=1) { 								//forces 32 bit
				thisBit = 1 << j;
				if ((other[i] & thisBit) == thisBit) {
					result = this.shiftLeft(i*32 + j).add(result);		//Forces 32 bit 
				}
			}
		}
		
		return result;
	}
	
	ArbInt -- mult(ArbInt other) {
		return finalizeArbIntFromNumList(mult(other.toNumList()));
	}
	
	ArbInt -- bitNot() {
		var not Num[] = [];
		for (var Num i=0; i<Num[].getSize();i+=1) {
			not.push(~Num[i]);
		}
		return ArbInt(not) from this;
	}
	
	private Num[] -- bitGate(Num[] other, Num -- fn(Num, Num) op) {
		//Uses Closures for code reuse.  Intended for any two input bitwise logic gate.
		var Num i = 0;
		
		var Num[] a = [];
		var Num[] b = [];
		var Num[] result = [];
		
		if (Num[].getSize() >= other.getSize()) {
			a = Num[];
			b = other;
		} else {
			a = other;
			b = Num[];
		}
		
		var Num mostWords = a.getSize();
		
		var Num pad = 0;
		if ((b[b.getSize()-1] & leftBit) == leftBit) {
			pad = -1;
		}
		
		for (i=0; i<mostWords; i+=1) {
			if (i < b.getSize()) {
				result.push(op(a[i], b[i]));
			} else {
				result.push(op(a[i], pad));
			}
		}

		return result;
	}

	private Num[] -- bitAnd(Num[] other) {
		return bitGate(other, {a, b => a & b});
	}
	
	private Num[] -- bitOr(Num[] other) {
		return bitGate(other, {a, b => a | b});
	}
	
	private Num[] -- bitXor(Num[] other) {
		return bitGate(other, {a, b => a ^ b});
	}
	
	ArbInt -- bitAnd(ArbInt other) {
		return finalizeArbIntFromNumList(bitGate(other.toNumList(), {a, b => a & b}));
	}
	
	ArbInt -- bitOr(ArbInt other) {
		return finalizeArbIntFromNumList(bitGate(other.toNumList(), {a, b => a | b}));
	}
	
	ArbInt -- bitXor(ArbInt other) {
		return finalizeArbIntFromNumList(bitGate(other.toNumList(), {a, b => a ^ b}));
	}
	
	private Num[] -- shiftRightNumList(Num amount) {
		var Num i = 0;
		
		var Num[] shifted = [];
		
		var Num pad = 0;
		if ((leftBit & Num[Num[].getSize() - 1]) == leftBit) {
			pad = -1;
		}
	
		var Num wordShift = (amount / 32).floor();					//FORCES 32 BIT
		if (wordShift < Num[].getSize()) {
			var Num bitShift = amount % 32;							//FORCES 32 BIT
			var Num opBitShift = 0;
			var Num mask = 0;
			if (bitShift != 0) {
				opBitShift = 32 - bitShift;
				mask = ~(-1 << (opBitShift));
			}

			for (i=0; i<Num[].getSize(); i+=1) {
				shifted.push(Num[i]);
			}

			shifted.push(pad);
		
			for (i=0; i<Num[].getSize()-wordShift; i+=1) {
				shifted[i] = (shifted[i+wordShift] >> bitShift) & mask;
				shifted[i] = shifted[i] | (shifted[i+wordShift+1] << (opBitShift));
			}
			for (i=Num[].getSize()-wordShift; i<Num[].getSize(); i+=1) {
				shifted[i] = pad;
			}
		} else {
			shifted = [pad];
		}
		
		return shifted;
	}
	
	ArbInt -- shiftRight(Num amount) {
		return finalizeArbIntFromNumList(shiftRightNumList(amount));
	}
	
	private Num[] -- shiftLeftNumList(Num amount) {
		var Num i = 0;
		
		var Num[] shifted = [];
		
		var Num pad = 0;
		if ((leftBit & Num[Num[].getSize() - 1]) == leftBit) {
			pad = -1;
		}
	
		var Num wordShift = (amount / 32).floor();					//FORCES 32 BIT
		var Num bitShift = amount % 32;								//FORCES 32 BIT
		var Num mask = ~(-1 << bitShift);
		var Num opBitShift = 0;
		if (bitShift !=0) {
			opBitShift = 32 - bitShift;
		}

		for (i=0; i<Num[].getSize(); i+=1) {
			shifted.push(Num[i]);
		}

		for (i=0; i<wordShift+1; i+=1) {
			shifted.push(pad);
		}

		for (i=shifted.getSize()-1; i>=wordShift+1; i-=1) {
			shifted[i] = shifted[i-wordShift] << bitShift;
			shifted[i] = shifted[i] | ((shifted[i-wordShift-1] >> opBitShift) & mask);
		}
		shifted[wordShift] = shifted[0] << bitShift;

		for (i=wordShift-1; i>=0; i-=1) {
			shifted[i] = 0;
		}
		
		return shifted;
	}
	
	ArbInt -- shiftLeft(Num amount) {
		return finalizeArbIntFromNumList(shiftLeftNumList(amount));
	}
	
	ArbInt -- finalizeArbIntFromNumList(Num[] a) {
		var ArbInt = ArbInt(a) from this;
		ArbInt.removePadding();
		
		return ArbInt;
	}
	
	removePadding() {						//Should maybe be a helper class for testing purposes?
		var Num i = 0;
		var Num wordCount = Num[].getSize();
		//Crop off any unecessary words that contain all 0s or all 1s
		if ((Num[wordCount - 1] == -1) || (Num[wordCount - 1] == 0)) {
			var Num chopAt = 0;
			for (i = wordCount -1; i >= 0; i-=1) {
				if ((Num[i] != Num[wordCount-1])) {
					//Be sure that the "unecessary" word doesn't contain the sign bit
					if (((Num[i] ^ Num[wordCount - 1]) & leftBit) == leftBit) {
						chopAt = i+1;
					} else {
						chopAt = i;
					}
					break;
				}
			}
			var Num[] final = [];
			for (i = 0; i <= chopAt; i+=1) {
				final.push(Num[i]);
			}
			Num[] = final;
		}
	}
	
	Num -- wordCount() {
		return Num[].getSize();
	}

	Num[] -- toNumList() {
		return Num[];
	}
	
	Num? -- toNum() {
		return toString().parseNum();
	}
	
	Text -- toString() {
		var Num i = 0;
		var Num j = 0;
		var Num rightFourBits = 15;
		var Text hexChars = '0123456789ABCDEF';
		
		var Text = "";
		
		var Bool sign = false;
		if ((leftBit & Num[Num[].getSize() - 1]) == leftBit) {
			sign = true;
		}
		
		var Bool signFixed = false;
		
		for (i=0; i < Num[].getSize(); i+=1) {
			for (j=0; j < 8; j+=1) {								//FORCES 32 BIT
				var Num = (Num[i] >> j*4) & rightFourBits;
				if (sign) {
					Num = 15 - Num;
					if (!(signFixed)) {
						if (Num == 15) {
							Num = 0;
						} else {
							Num += 1;
							signFixed = true;
						}
					}
				}
				var Text? nextChar = hexChars.charAt(Num);
				if nextChar exists {
					Text = nextChar + Text;
				}
			}
		}
		
		var Num chopAt = Text.getSize()-1;
		for (i=0; i < Text.getSize(); i+=1) {
			if (Text.substr(i,i+1) != '0') {
				chopAt = i;
				break;
			}
		}
		
		Text = Text.substr(chopAt,Text.getSize());
		
		if (sign) {
			Text = "-0x" + Text;
		} else {
			Text = "0x" + Text;
		}
		
		return Text;
	}